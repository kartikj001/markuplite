<!-- Author : Kartik Jadhav. Copyrights © 2024, Kartik Jadhav, All rights reserved. Any kind of duplication of work is not allowed. -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MarkupLite</title>
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 12px;
        margin: 0;
        padding: 0;
        background-color: #1d1d1d; /* Dark background */
        color: #e1e1e1; /* Light text color */
        overflow-x: hidden; /* Prevent horizontal scrolling */
    }

    .container {
        text-align: center;
        background-color: #2f2f2f; /* Slightly lighter dark background */
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        padding: 20px;
        max-width: 100%;
        width: 90%;
        margin: 0 auto;
        overflow: auto; /* Enable scrolling if content is larger */
    }

    #imageCanvas {
        border: 1px solid #3c3c3c; /* Slightly lighter border */
        display: block;
        margin: 10px auto;
        cursor: crosshair;
        background-color: #2f2f2f;
        max-width: 100%;
        height: auto;
    }

    .controls {
        margin-top: 10px;
    }

    .controls textarea {
        padding: 10px;
        font-size: 12px;
        margin-bottom: 10px;
        display: block;
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
        border-radius: 4px;
        border: 1px solid #444; /* Darker border for contrast */
        background-color: #1e1e1e; /* Dark background for textarea */
        color: #e1e1e1; /* Light text color */
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .controls button,
    #imageUpload,
    #pasteImageBtn {
        padding: 10px 15px;
        font-size: 12px;
        cursor: pointer;
        margin: 5px;
        border: 1px solid #444;
        border-radius: 4px;
        color: #e1e1e1;
        transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        background-color: #3d3d3d; /* Darker background for buttons */
    }

    .controls button.active,
    .controls button:hover,
    #pasteImageBtn:hover,
    #imageUpload:hover {
        background-color: #5c2a9e; /* violet */
        color: #ffffff;
        border-color: #5c2a9e;
    }

    .controls .button-group {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
    }

    .controls .button-group button {
        background-color: #3d3d3d;
    }

    #imageButtonsContainer {
        display: flex;
        justify-content: center;
        margin-top: 10px;
        flex-wrap: wrap;
    }

    #imageButtonsContainer button {
        padding: 10px 15px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        color: #fff;
        background: linear-gradient(45deg, #6c63ff, #5c2a9e); /* violet gradient */
        transition: background 0.3s, transform 0.3s;
    }

    #imageButtonsContainer button:hover {
        background: linear-gradient(45deg, #5c2a9e, #3e0a4b); /* Darker violet on hover */
        transform: scale(1.05);
    }

    #copyImageBtn {
        background-color: #3d3d3d;
        border-color: #444;
        color: #e1e1e1;
    }

    #copyImageBtn:hover {
        background-color: #5c2a9e;
        color: #ffffff;
        border-color: #5c2a9e;
    }

    #welcomeModal {
        display: flex;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8); /* Darker overlay */
        color: #e1e1e1;
        z-index: 1000;
    }

    #welcomeModal .modal-content {
        background: #2f2f2f;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
    }

    #welcomeModal button {
        padding: 10px 20px;
        margin: 10px;
        border: none;
        border-radius: 4px;
        background-color: #5c2a9e; /* violet */
        color: #ffffff;
        cursor: pointer;
    }

    #welcomeModal button:hover {
        background-color: #3e0a4b; /* Darker violet on hover */
    }

    @media (max-width: 1200px) {
        .container {
            width: 95%;
        }
    }

    @media (max-width: 900px) {
        .controls textarea {
            font-size: 10px;
            padding: 8px;
        }

        .controls button {
            padding: 8px 12px;
            font-size: 10px;
        }
    }

    @media (max-width: 600px) {
        .controls {
            margin-top: 5px;
        }
        
        .controls button {
            padding: 8px 12px;
            font-size: 10px;
        }

        #imageCanvas {
            margin: 5px auto;
            max-width: 100%;
        }
    }

    @media (max-width: 400px) {
        .controls textarea {
            font-size: 8px;
            padding: 6px;
        }

        .controls button {
            padding: 6px 10px;
            font-size: 8px;
        }
    }
</style>
</head>
<body>
    <div id="welcomeModal">
        <div class="modal-content">
            <h2>Welcome to Markup<i>Lite</i></h2>
            <p>Upload or Paste image from clipboard to get started.<br> This site is not available on mobile devices. Please access it from a PC or laptop.</p>
            <button onclick="closeWelcomeModal()">Get Started</button>
        </div>
    </div>

    <div class="container">
        <h1>Markup<i>Lite</i></h1>

        <!-- File Input to Upload Image -->
        <div class="button-group">
            <input type="file" id="imageUpload" accept="image/*">
            <button id="pasteImageBtn" onclick="pasteImageFromClipboard()">Paste Image</button>
        </div>
        <br>

        <!-- Controls Section -->
        <div class="controls">
            <textarea id="description" rows="4" placeholder="Add Title"></textarea>
          <br>
            <div class="button-group">
                <button id="addTextBtn" onclick="addTextToImage()">Add Title</button>
                <button id="addMarkupBtn" onclick="enableAddMarkup()">Add Markups</button>
                <button id="addArrowsBtn" onclick="enableAddArrows()">Add Arrows</button>
                <button id="addTextBoxBtn" onclick="enableAddTextBox()">Add Text-Box</button>
                <button id="addDimensionBtn" onclick="enableAddDimension()">Add Dimension</button>
                <button id="removeAllMarkupsBtn" onclick="removeAllMarkups()">Remove All Markups</button>
                <button id="undoBtn" onclick="undo()">Undo</button>
            </div>
        </div>

        <!-- Canvas where image and markup will be displayed -->
        <canvas id="imageCanvas"></canvas>
        
        <!-- Button to copy the image -->
        <div id="imageButtonsContainer">
            <button id="copyImageBtn" onclick="copyImageToClipboard()">Copy Image</button>
        </div>
        <p style="text-align:center;"> Copyright © 2024, Kartik Jadhav, All rights reserved.</p>
    </div>

<script>
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');
let uploadedImage = null;
const circles = [];
const arrows = [];
const textBoxes = [];
const dimensions = [];
let addMode = true;
let arrowMode = false;
let textBoxMode = false;
let dimensionMode = false; // For dimensions
let startPoint = null;
let tempEndPoint = null; // Temporary end point for live feedback
const undoStack = [];
const MAX_UNDO_STACK = 100;
let circleCount = 1;

function setCanvasSize(img) {
  const aspectRatio = img.width / img.height;
  const maxWidth = 1000;
  const maxHeight = 800;

  if (img.width > img.height) {
    canvas.width = Math.min(maxWidth, img.width);
    canvas.height = canvas.width / aspectRatio;
  } else {
    canvas.height = Math.min(maxHeight, img.height);
    canvas.width = canvas.height * aspectRatio;
  }
}

document.getElementById('imageUpload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  const reader = new FileReader();
  const img = new Image();

  reader.onload = function(e) {
    img.src = e.target.result;
  };

  img.onload = function() {
    uploadedImage = img;
    setCanvasSize(img);
    drawImageWithMarkup();
  };

  reader.readAsDataURL(file);
});

function addTextToImage() {
  addStateToUndoStack();
  drawImageWithMarkup();
}

function enableAddMarkup() {
  addMode = true;
  arrowMode = false;
  textBoxMode = false;
  dimensionMode = false;
  highlightButton('addMarkupBtn');
}

function enableAddArrows() {
  addMode = false;
  arrowMode = true;
  textBoxMode = false;
  dimensionMode = false;
  highlightButton('addArrowsBtn');
}

function enableAddTextBox() {
  addMode = false;
  arrowMode = false;
  textBoxMode = true;
  dimensionMode = false;
  highlightButton('addTextBoxBtn');
}

function enableAddDimension() {
  addMode = false;
  arrowMode = false;
  textBoxMode = false;
  dimensionMode = true; // Activate dimension mode
  highlightButton('addDimensionBtn');
}

function removeAllMarkups() {
  addStateToUndoStack();
  circles.length = 0;
  arrows.length = 0;
  textBoxes.length = 0;
  dimensions.length = 0;
  drawImageWithMarkup();
}

function highlightButton(buttonId) {
  document.querySelectorAll('.controls button').forEach(button => {
    button.classList.remove('active');
  });
  document.getElementById(buttonId).classList.add('active');
}

function copyImageToClipboard() {
  canvas.toBlob(blob => {
    const item = new ClipboardItem({ 'image/png': blob });
    navigator.clipboard.write([item]).then(() => {
      alert('Image copied to clipboard!');
    });
  });
}

function drawImageWithMarkup() {
  // Clear canvas and fill with white background
  ctx.fillStyle = 'white'; // Set the background color to white
  ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the entire canvas

  if (uploadedImage) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);
  }

  // Draw circles
  circles.forEach((circle, index) => {
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circle.radius / 3, 0, Math.PI * 2);
    ctx.fillStyle = 'red';
    ctx.fill();
    ctx.font = '12px Arial';
    ctx.fillStyle = 'blue';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(index + 1, circle.x + circle.radius + 10, circle.y);
  });

  // Draw arrows
  arrows.forEach(arrow => drawArrow(arrow.start, arrow.end));

  // Draw text boxes
  textBoxes.forEach(box => {
    ctx.fillStyle = 'black';
    ctx.fillRect(box.x - 3, box.y - 20, box.width + 5, 30);
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '12px Arial';
    ctx.fillText(box.text, box.x + box.width / 2, box.y - 5);
  });

  // Draw dimensions
  dimensions.forEach(dimension => drawDimension(dimension.start, dimension.end, dimension.text));

  const description = document.getElementById('description').value;
  if (description) {
    ctx.fillStyle = 'black';
    const textX = canvas.width / 2;
    ctx.font = '12px Arial';
    const lineHeight = 16;
    const lines = description.split('\n');
    const maxLineWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
    const textHeight = lineHeight * lines.length;
    ctx.fillRect(0, canvas.height - textHeight - 10, canvas.width, textHeight + 10);
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = '12px Arial';
    lines.forEach((line, index) => {
      ctx.fillText(line, textX, canvas.height - textHeight + (lineHeight * index));
    });
  }
}

function drawArrow(start, end) {
  const headLength = 10;
  const angle = Math.atan2(end.y - start.y, end.x - start.x);
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(end.x, end.y);
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'blue';
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(end.x, end.y);
  ctx.lineTo(end.x - headLength * Math.cos(angle - Math.PI / 6), end.y - headLength * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(end.x - headLength * Math.cos(angle + Math.PI / 6), end.y - headLength * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(end.x, end.y);
  ctx.fillStyle = 'blue';
  ctx.fill();
}

function drawDimension(start, end, text) {
  // Draw the dimension line
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(end.x, end.y);
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'red';
  ctx.stroke();

  // Draw open tick marks at both ends (architectural style)
  drawOpenTick(start, end);
  drawOpenTick(end, start);

  // Draw dimension text
  const textX = (start.x + end.x) / 2;
  const textY = (start.y + end.y) / 2;
  ctx.fillStyle = 'black';
  ctx.fillRect(textX - ctx.measureText(text).width / 2 - 3, textY - 10, ctx.measureText(text).width + 6, 20);
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '12px Arial';
  ctx.fillText(text, textX, textY);
}

function drawOpenTick(pointA, pointB) {
  const dotRadius = 4; // Define the radius of the dot

  // Draw a dot (circle) at pointA
  ctx.beginPath();
  ctx.arc(pointA.x, pointA.y, dotRadius, 0, 2 * Math.PI); // Draw a small circle (dot)
  ctx.fillStyle = 'red'; // Set the dot color
  ctx.fill();
}

function addStateToUndoStack() {
  if (undoStack.length >= MAX_UNDO_STACK) {
    undoStack.shift();
  }
  undoStack.push({ circles: [...circles], arrows: [...arrows], textBoxes: [...textBoxes], dimensions: [...dimensions] });
}

function undo() {
  if (undoStack.length > 0) {
    const lastState = undoStack.pop();
    circles.length = 0;
    arrows.length = 0;
    textBoxes.length = 0;
    dimensions.length = 0;
    circles.push(...lastState.circles);
    arrows.push(...lastState.arrows);
    textBoxes.push(...lastState.textBoxes);
    dimensions.push(...lastState.dimensions);
    drawImageWithMarkup();
  } else {
    alert("No more actions to undo.");
  }
}

function closeWelcomeModal() {
  document.getElementById('welcomeModal').style.display = 'none';
}

window.addEventListener('beforeunload', function(event) {
  event.preventDefault();
  event.returnValue = '';
});

canvas.addEventListener('mousedown', function(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  if (dimensionMode) {
    startPoint = { x, y };
    tempEndPoint = null; // Clear temporary end point
  } else if (arrowMode) {
    startPoint = { x, y };
  } else if (textBoxMode) {
    const text = prompt("Enter text for the text box:");
    if (text === null) {
      textBoxMode = false; // Exit text box mode if canceled
      return;
    }
    addStateToUndoStack();
    textBoxes.push({ x, y, width: ctx.measureText(text).width + 10, text });
    drawImageWithMarkup();
  }
});

canvas.addEventListener('mousemove', function(event) {
  if (dimensionMode && startPoint) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    tempEndPoint = { x, y }; // Update temporary end point for live feedback

    drawImageWithMarkup(); // Redraw everything including the temporary dimension line

    // Draw temporary dimension line for live feedback
    ctx.beginPath();
    ctx.moveTo(startPoint.x, startPoint.y);
    ctx.lineTo(tempEndPoint.x, tempEndPoint.y);
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // Light red color for live feedback
    ctx.stroke();
  }
});

canvas.addEventListener('mouseup', function(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  if (dimensionMode && startPoint) {
    // Finalize the dimension
    const dimensionText = prompt("Enter the dimension value:");
    if (dimensionText === null) {
      dimensionMode = false; // Exit dimension mode if canceled
      startPoint = null;
      tempEndPoint = null; // Clear temporary end point
      return;
    }
    addStateToUndoStack();
    dimensions.push({ start: startPoint, end: { x, y }, text: dimensionText });
    startPoint = null;
    tempEndPoint = null; // Clear temporary end point
    drawImageWithMarkup();
  } else if (arrowMode && startPoint) {
    addStateToUndoStack();
    arrows.push({ start: startPoint, end: { x, y } });
    startPoint = null;
    drawImageWithMarkup();
  }
});

canvas.addEventListener('click', function(event) {
  if (dimensionMode || arrowMode || textBoxMode) return; // Prevent circle drawing in other modes

  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const radius = 20;

  if (addMode) {
    addStateToUndoStack();
    circles.push({ x, y, radius });
    circleCount++;
  } else {
    const index = circles.findIndex(circle => {
      const dx = circle.x - x;
      const dy = circle.y - y;
      return Math.sqrt(dx * dx + dy * dy) < radius;
    });
    if (index !== -1) {
      addStateToUndoStack();
      circles.splice(index, 1);
    }
  }

  drawImageWithMarkup();
});

function pasteImageFromClipboard() {
  navigator.clipboard.read().then(items => {
    items.forEach(item => {
      if (item.types.includes('image/png')) {
        item.getType('image/png').then(blob => {
          const img = new Image();
          img.src = URL.createObjectURL(blob);
          img.onload = function() {
            uploadedImage = img;
            setCanvasSize(img);
            drawImageWithMarkup();
          };
        });
      }
    });
  });
}

// Initialize the canvas when the page loads
document.addEventListener('DOMContentLoaded', () => {
  canvas.width = 1000; // Set default width
  canvas.height = 800; // Set default height
  drawImageWithMarkup(); // Fill canvas with white background
});

</script>


</body>
</html>
